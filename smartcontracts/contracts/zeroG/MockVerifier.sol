// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "./interfaces/IERC7857DataVerifier.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";

/**
 * @title MockVerifier
 * @notice Simplified TEE verifier for hackathon - accepts all valid signatures without real attestation
 * @dev This is a mock implementation for demo purposes. Production would use actual TEE attestation.
 */
contract MockVerifier is IERC7857DataVerifier {
    using ECDSA for bytes32;
    using MessageHashUtils for bytes32;

    // Prevent replay attacks
    mapping(bytes32 => bool) private usedProofs;
    mapping(bytes32 => uint256) private proofTimestamps;

    event ProofVerified(bytes32 indexed proofNonce, address indexed accessAssistant);

    error ProofAlreadyUsed(bytes32 proofNonce);
    error InvalidAccessAssistant();
    error InvalidOwnershipProof();
    error DataHashMismatch();

    function _checkAndMarkProof(bytes32 proofNonce) internal {
        if (usedProofs[proofNonce]) {
            revert ProofAlreadyUsed(proofNonce);
        }
        usedProofs[proofNonce] = true;
        proofTimestamps[proofNonce] = block.timestamp;
    }

    /// @notice Clean expired proof records (save gas)
    function cleanExpiredProofs(bytes32[] calldata proofNonces) external {
        for (uint256 i = 0; i < proofNonces.length; i++) {
            bytes32 nonce = proofNonces[i];
            if (usedProofs[nonce] && block.timestamp > proofTimestamps[nonce] + 7 days) {
                delete usedProofs[nonce];
                delete proofTimestamps[nonce];
            }
        }
    }

    /// @notice Verify access proof signature
    function verifyAccessibility(
        AccessProof memory accessProof
    ) private pure returns (address) {
        bytes32 messageHash = keccak256(
            abi.encodePacked(
                accessProof.oldDataHash,
                accessProof.newDataHash,
                accessProof.encryptedPubKey,
                accessProof.nonce
            )
        );

        bytes32 ethSignedHash = messageHash.toEthSignedMessageHash();
        address accessAssistant = ethSignedHash.recover(accessProof.proof);
        
        if (accessAssistant == address(0)) {
            revert InvalidAccessAssistant();
        }
        
        return accessAssistant;
    }

    /// @notice Mock ownership proof verification (simplified for hackathon)
    function verifyOwnershipProof(
        OwnershipProof memory ownershipProof
    ) private pure returns (bool) {
        // In production, this would verify TEE attestation
        // For hackathon, we do basic signature verification
        if (ownershipProof.oracleType == OracleType.TEE) {
            bytes32 messageHash = keccak256(
                abi.encodePacked(
                    ownershipProof.oldDataHash,
                    ownershipProof.newDataHash,
                    ownershipProof.sealedKey,
                    ownershipProof.encryptedPubKey,
                    ownershipProof.nonce
                )
            );

            bytes32 ethSignedHash = messageHash.toEthSignedMessageHash();
            address signer = ethSignedHash.recover(ownershipProof.proof);
            
            // Mock: accept any valid signature
            return signer != address(0);
        }
        
        // ZKP not implemented for hackathon
        return false;
    }

    /// @notice Process a single transfer validity proof
    function processTransferProof(
        TransferValidityProof calldata proof
    ) private pure returns (TransferValidityProofOutput memory output) {
        // Verify data hashes match
        if (proof.accessProof.oldDataHash != proof.ownershipProof.oldDataHash) {
            revert DataHashMismatch();
        }
        output.oldDataHash = proof.accessProof.oldDataHash;

        if (proof.accessProof.newDataHash != proof.ownershipProof.newDataHash) {
            revert DataHashMismatch();
        }
        output.newDataHash = proof.accessProof.newDataHash;

        output.wantedKey = proof.accessProof.encryptedPubKey;
        output.accessProofNonce = proof.accessProof.nonce;
        output.encryptedPubKey = proof.ownershipProof.encryptedPubKey;
        output.sealedKey = proof.ownershipProof.sealedKey;
        output.ownershipProofNonce = proof.ownershipProof.nonce;

        // Verify the access assistant
        output.accessAssistant = verifyAccessibility(proof.accessProof);

        // Verify ownership proof
        bool isOwn = verifyOwnershipProof(proof.ownershipProof);
        if (!isOwn) {
            revert InvalidOwnershipProof();
        }

        return output;
    }

    /// @notice Verify data transfer validity
    /// @param proofs Proof generated by TEE/ZKP oracle
    function verifyTransferValidity(
        TransferValidityProof[] calldata proofs
    ) external override returns (TransferValidityProofOutput[] memory) {
        TransferValidityProofOutput[] memory outputs = new TransferValidityProofOutput[](
            proofs.length
        );

        for (uint256 i = 0; i < proofs.length; i++) {
            TransferValidityProofOutput memory output = processTransferProof(proofs[i]);
            outputs[i] = output;

            bytes32 accessProofNonce = keccak256(output.accessProofNonce);
            _checkAndMarkProof(accessProofNonce);

            bytes32 ownershipProofNonce = keccak256(output.ownershipProofNonce);
            _checkAndMarkProof(ownershipProofNonce);

            emit ProofVerified(accessProofNonce, output.accessAssistant);
        }

        return outputs;
    }

    /// @notice Check if a proof nonce has been used
    function isProofUsed(bytes32 proofNonce) external view returns (bool) {
        return usedProofs[proofNonce];
    }
}

